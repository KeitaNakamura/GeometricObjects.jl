function vtk_format(x::AbstractVector{Vec{dim, T}}) where {dim, T}
    reinterpret(reshape, T, x)
end
function vtk_format(x::SVector{<: Any, Vec{dim, T}}) where {dim, T}
    reshape(vcat(x...), (dim, length(x)))
end

function WriteVTK.vtk_grid(vtk::AbstractString, line::Line; kwargs...)
    coords = vtk_format(coordinates(line))
    cells = [MeshCell(VTKCellTypes.VTK_LINE, 1:size(coords, 2))]
    vtk_grid(vtk, coords, cells; kwargs...)
end

function WriteVTK.vtk_grid(vtk::AbstractString, poly::Polygon; kwargs...)
    coords = vtk_format(coordinates(poly))
    cells = [MeshCell(VTKCellTypes.VTK_POLYGON, 1:size(coords, 2))]
    vtk_grid(vtk, coords, cells; kwargs...)
end

function WriteVTK.vtk_grid(vtk::AbstractString, circle::Circle; kwargs...)
    θᵢ = LinRange(0, 2π, 360)
    coords = vtk_format([centroid(circle) + radius(circle) * Vec(cos(θ), sin(θ)) for θ in θᵢ])
    cells = [MeshCell(VTKCellTypes.VTK_POLYGON, 1:size(coords, 2))]
    vtk_grid(vtk, coords, cells; kwargs...)
end

function WriteVTK.vtk_grid(vtk::AbstractString, sphere::Sphere{2}; kwargs...)
    vtk_grid(vtk, Circle(centroid(sphere), radius(sphere)); kwargs...)
end

# reference values are generated by Gmsh
const SPHERE_REF_POINTS = vec(reinterpret(Vec{3, Float64}, readdlm(joinpath(@__DIR__, "../assets/sphere_ref_points.txt"), Float64)'))
const SPHERE_REF_CELLS  = vec(reinterpret(NTuple{3, Int}, readdlm(joinpath(@__DIR__, "../assets/sphere_ref_cells.txt"), Int)' .+ 1))
function WriteVTK.vtk_grid(vtk::AbstractString, sphere::Sphere{3}; kwargs...)
    coords = reinterpret(reshape, Float64, radius(sphere) * SPHERE_REF_POINTS .+ centroid(sphere))
    cells = [MeshCell(VTKCellTypes.VTK_TRIANGLE, connectivity) for connectivity in SPHERE_REF_CELLS]
    vtk_grid(vtk, coords, cells; kwargs...)
end

WriteVTK.vtk_grid(vtk::AbstractString, obj::GeometricObject; kwargs...) = vtk_grid(vtk, geometry(obj); kwargs...)
